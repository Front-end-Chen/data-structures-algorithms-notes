# 46-全排列

### 给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**



### 深度优先遍历、递归、栈，它们三者的关系，我个人以为它们背后统一的逻辑都是「后进先出」。

### 与动态规划的区别：
**1）共同点**

用于求解多阶段决策问题。多阶段决策问题即：

- 求解一个问题分为很多步骤（阶段）；

- 每一个步骤（阶段）可以有多种选择。

**2）不同点**

- 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；

- 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。



## 方法一：回溯 + 空间换时间的优化

#### 时间复杂度： O(n∗n!)，其中 n 为序列的长度。每个排列需要 O(n) (即push的时间) 复制来放入res数组中。

#### 空间复杂度：O(n)  不计算res数组

### 从全排列问题开始理解回溯算法

<img src='img/回溯图解.png' />

**说明：**

每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；

使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；

深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；

深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。

使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。

### 设计状态变量

首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；

递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；

布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。

这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。

### 剪枝

回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；

**提示：** 剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。

由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。

### 总结

做题的时候，建议 **先画树形图** ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。

在画图的过程中思考清楚：

分支如何产生；

题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从根结点到叶子结点的路径？

哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？


```javascript
var permute = function (nums) {
    if (!nums.length) return []
    let res = []
    const dfs = path => {
        if (path.length == nums.length) {
            res.push([...path])
            return
        }
        for (let i = 0; i < nums.length; i++) {
            if (path.includes(nums[i])) continue  // 查询操作是O(n)
            path.push(nums[i])
            dfs(path)
            path.pop()
        }
    }
    dfs([])
    return res
};

// 回溯优化
var permute = function (nums) {
    if (!nums.length) return []
    let res = []
    let used = []  // 空间换时间，添加每个数是否被选的状态数组
    const dfs = path => {
        if (path.length == nums.length) {
            res.push([...path])
            return
        }
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue  // 优化查询操作为O(1)
            path.push(nums[i])
            used[i] = true
            dfs(path)
            used[i] = false
            path.pop()
        }
    }
    dfs([])
    return res
};

// 回溯优化2
var permute = function (nums) {
    if (!nums.length) return []
    let res = []
    let used = []  // 空间换时间，添加每个数是否被选的状态数组
    const dfs = path => {
        if (path.length == nums.length) {
            res.push([...path])
            return
        }
        for (let i = 0; i < nums.length; i++) {
            if (!used[i]) {  // 优化查询操作为O(1)
                path.push(nums[i])
                used[i] = true
                dfs(path)
                used[i] = false
                path.pop()
            }
        }
    }
    dfs([])
    return res
};
```

