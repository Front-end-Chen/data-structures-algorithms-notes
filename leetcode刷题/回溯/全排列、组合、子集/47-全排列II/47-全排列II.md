# 47-全排列II

### 给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

**示例:**

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`



## 方法一：回溯 + 剪枝

#### 时间复杂度： O(n∗n!)，其中 n 为序列的长度。每个排列需要 O(n) (即push的时间) 复制来放入res数组中。

#### 空间复杂度：O(n)  不计算res数组

### 思路：排序 + 剪枝。在遍历的过程中，一边遍历一遍检测，**在一定会产生重复结果集的地方剪枝**。

### 递归树：

<img src='img/回溯+剪枝.png' />

产生重复结点的地方，正是图中标注了「剪刀」，且被绿色框框住的地方。

大家也可以把第 2 个 1 加上 ' ，即 [1, 1', 2] 去想象这个搜索的过程。只要遇到起点一样，就有可能产生重复。这里还有一个很细节的地方：

- 在图中 ② 处，搜索的数也和上一次一样，但是上一次的 1 还在使用中；

- **在图中 ① 处，搜索的数也和上一次一样，但是上一次的 1 刚刚被撤销，正是因为刚被撤销，下面的搜索中还会使用到，因此会产生重复，剪掉的就应该是这样的分支。**

代码实现方面，在全排列的基础上，要加上这样一段代码：

```js
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    continue;
}
```

这段代码就能检测到标注为 ① 的两个结点，跳过它们。注意：这里 used[i - 1] 不加 !，测评也能通过。有兴趣的朋友可以想一想这是为什么。建议大家做这样几个对比实验：

- 干脆就不写 !used[i - 1] 结果是什么样？
- 写 used[i - 1] 结果是什么，代码又是怎样执行的。**这里给出的结论是：!used[i - 1] 这样的剪枝更彻底。**

```javascript
var permuteUnique = function (nums) {
    if (!nums.length) return []
    let res = []
    let used = []
    nums.sort((a, b) => a - b)  // 排序（升序或者降序都可以），为了便于剪枝，使相同的元素相邻
    const dfs = path => {
        if (path.length == nums.length) {  // 个数选够了
            res.push([...path])
            return
        }
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue
            // 剪枝条件：i > 0 是为了保证 nums[i - 1] 有意义
            // !used[i - 1] 是表示 nums[i - 1] ·未被选择过 
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue
            path.push(nums[i])
            used[i] = true
            dfs(path)
            used[i] = false
            path.pop()
        }
    }
    dfs([])
    return res
};
```

